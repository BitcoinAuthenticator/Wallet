package authenticator.protobuf;

option java_outer_classname="ProtoConfig";

import "AuthWalletHierarchy.proto";

enum ATGCMMessageType{
	SignTX 					= 2;
	UpdatePendingRequestIPs	= 4;
}

enum ATOperationType {
    Pairing 							= 0;
	Unpair 								= 1;
	SignAndBroadcastAuthenticatorTx		= 2;
	BroadcastNormalTx					= 3;
	updateIpAddressesForPreviousMessage = 4;
}

enum ActiveAccountType {
    Spending	 	= 0;
    Savings			= 1;
	Authenticator 	= 2;
}

message ATAddress{
	optional int32 accountIndex			= 1; 
	optional int32 keyIndex				= 2;
	required string addressStr			= 3;
	optional bool isUsed				= 4; 
	optional HierarchyAddressTypes type	= 5;
}

//
//	Pairing Data
//
message PairedAuthenticator{
	required string 	aes_key 			= 1;
	required string 	master_public_key 	= 2;
	required string 	chain_code 			= 3;
	required string 	GCM 				= 4;
	required string 	pairingID 			= 5;
	required bool 		testnet 			= 6;
	required int32 		keys_n 				= 7;
	//repeated KeysObject generatedKeys 	= 8; // no need to cache them
	required string 	pairingName 		= 9;
	required int32		walletAccountIndex	= 10;
}

//
//	Pending Requests Data
//

message PendingRequest{
	
  	message Contract{
  		optional bool ShouldSendPayloadOnConnection 									= 1;
  		optional bool ShouldReceivePayloadAfterSendingPayloadOnConnection 		 		= 2;
  	}

	required string pairingID 									= 1;
	required string requestID 									= 2;
	required ATOperationType operationType					 	= 3;
	optional string rawTx 										= 4;
	optional bytes payloadIncoming 								= 5;
	optional bytes payloadToSendInCaseOfConnection 				= 6;
	required Contract contract 									= 7;
}


////////////////////////////////////////////////////////////////////////
//
//
//
//
//
//	Configuration message, holds all the settings of the wallet
//
//
//
//
//
////////////////////////////////////////////////////////////////////////

message AuthenticatorConfiguration{
	message ConfigActiveAccount{
		optional PairedAuthenticator pairedAuthenticator = 1;
		required ActiveAccountType activeAccountType 	 = 2;
	}
	
	message ConfigAuthenticatorWallet {
	
	  	optional bool paired = 1;  // Whether or not the wallet is paired. This will be set to repeated when multi-account is finished.
		
		repeated PairedAuthenticator pairedWallets  = 2; 
		repeated PendingRequest pendingRequests 	= 3; 
	}
	
	message CachedExternalSpending {
		repeated ATAddress walletCachedExternalSpendingAddress = 1; // An array of (min 10) hex encoded public keys from the wallet that will be loaded in the receive pane.
	}
	
	//message ConfigAddressBook {
	
	//	optional string address = 1; // This is a placeholder for the address book.
	
	//}
	
	message ConfigOneNameProfile {
		required string onename	     			= 1; // The user's OneName ID. Used for getting the avatar on start up.
		optional string onenameFormatted	   	= 2;
		optional string onenameAvatarURL 		= 3;
		optional string onenameAvatarFilePath	= 4;
	}
	
	message ATAccount {
		required int32 index				= 1;
		required int32 lastExternalIndex	= 2;
		repeated int32 usedExternalKeys 	= 3;
		required int32 lastInternalIndex	= 4;
		repeated int32 usedInternalKeys 	= 5; 
	}
	
	optional ConfigActiveAccount configActiveAccount 				= 1;
	optional ConfigAuthenticatorWallet configAuthenticatorWallet	= 2;
	optional CachedExternalSpending cachedExternalSpending 			= 3;
	//optional ConfigAddressBook configAddressBook 					= 4;
	optional ConfigOneNameProfile configOneNameProfile				= 5;
	required bytes hierarchySeed									= 6;
	repeated ATAccount configAccounts								= 7;
}


